#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "BinaryData.h"

static float midiToHz (int n) { return 440.0f * std::pow (2.0f, (n - 69) / 12.0f); }

MaNiFyAuxProAudioProcessor::MaNiFyAuxProAudioProcessor()
: AudioProcessor (BusesProperties().withOutput ("Out", juce::AudioChannelSet::stereo(), true))
{
}

void MaNiFyAuxProAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    sr = sampleRate;
    pads.prepare (sr, samplesPerBlock, getTotalNumOutputChannels());
    bells.prepare(sr, samplesPerBlock, getTotalNumOutputChannels());
    ambient.prepare(sr, samplesPerBlock, getTotalNumOutputChannels());
    hits.prepare(sr, samplesPerBlock, getTotalNumOutputChannels());
    pluck.prepare(sr, samplesPerBlock, getTotalNumOutputChannels());

    // Load embedded samples from BinaryData (generated by Projucer)
    pads.loadSampleFromBinary (BinaryData::Pads_wav,    BinaryData::Pads_wavSize);
    bells.loadSampleFromBinary(BinaryData::Bells_wav,   BinaryData::Bells_wavSize);
    ambient.loadSampleFromBinary(BinaryData::Ambient_wav, BinaryData::Ambient_wavSize);
    hits.loadSampleFromBinary  (BinaryData::Hits_wav,   BinaryData::Hits_wavSize);
    pluck.loadSampleFromBinary (BinaryData::Pluck_wav,  BinaryData::Pluck_wavSize);
}

void MaNiFyAuxProAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    buffer.clear();
    analyseMidi (midi);

    juce::MidiBuffer activeMidi;
    for (auto m : midi) activeMidi.addEvent (m.getMessage(), m.samplePosition);

    switch (currentMode)
    {
        case Mode::Pads:    pads.process   (buffer, activeMidi); break;
        case Mode::Bells:   bells.process  (buffer, activeMidi); break;
        case Mode::Ambient: ambient.process(buffer, activeMidi); break;
        case Mode::Hits:    hits.process   (buffer, activeMidi); currentMode = Mode::Pads; break;
        case Mode::Pluck:   pluck.process  (buffer, activeMidi); currentMode = Mode::Pads; break;
    }
}

void MaNiFyAuxProAudioProcessor::analyseMidi (const juce::MidiBuffer& midi)
{
    int noteOnCount = 0;
    int minNote = 128, maxNote = -1;
    int velocitySum = 0;

    for (auto meta : midi)
    {
        const auto& m = meta.getMessage();
        if (m.isNoteOn())
        {
            ++noteOnCount;
            const int n = (int) m.getNoteNumber();
            minNote = std::min (minNote, n);
            maxNote = std::max (maxNote, n);
            velocitySum += (int) juce::jlimit (0, 127, (int) (m.getVelocity() * 127.0f));
        }
    }

    // Switching rules
    if (noteOnCount >= 2 && (maxNote - minNote) == 12)                          currentMode = Mode::Bells;     // RH octave
    else if (noteOnCount >= 2 && maxNote < 57 && (maxNote - minNote) == 12)     currentMode = Mode::Hits;      // Low octave hit
    else if (noteOnCount >= 3 && (velocitySum / juce::jmax (1, noteOnCount) < 45)) currentMode = Mode::Ambient; // Soft sustained
    else if (noteOnCount >= 5)                                                   currentMode = Mode::Pluck;     // Fast run
    else                                                                         currentMode = Mode::Pads;
}

const juce::String MaNiFyAuxProAudioProcessor::getCurrentModeName() const
{
    switch (currentMode) {
        case Mode::Pads:    return "Pads";
        case Mode::Bells:   return "Bells";
        case Mode::Ambient: return "Ambient";
        case Mode::Hits:    return "Hits";
        case Mode::Pluck:   return "Pluck";
        default:            return "Pads";
    }
}

juce::AudioProcessorEditor* MaNiFyAuxProAudioProcessor::createEditor()
{
    return new MaNiFyAuxProAudioProcessorEditor (*this);
}

// Factory method for JUCE
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MaNiFyAuxProAudioProcessor()
}
